<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Str` struct in crate `dstr`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Str">

    <title>dstr::Str - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'><a href='index.html'>dstr</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='raw/index.html'>raw</a></div><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.CharOffsets.html'>CharOffsets</a><a class='struct ' href='struct.CharRange.html'>CharRange</a><a class='struct ' href='struct.CharSplits.html'>CharSplits</a><a class='struct ' href='struct.CharSplitsN.html'>CharSplitsN</a><a class='struct ' href='struct.Chars.html'>Chars</a><a class='struct ' href='struct.MatchIndices.html'>MatchIndices</a><a class='struct current' href='struct.Str.html'>Str</a><a class='struct ' href='struct.StrSplits.html'>StrSplits</a><a class='struct ' href='struct.Utf16CodeUnits.html'>Utf16CodeUnits</a></div><div class='block trait'><h2>Traits</h2><a class='trait ' href='trait.AsStr.html'>AsStr</a></div><div class='block fn'><h2>Functions</h2><a class='fn ' href='fn.eq_slice.html'>eq_slice</a><a class='fn ' href='fn.is_utf8.html'>is_utf8</a><a class='fn ' href='fn.s.html'>s</a><a class='fn ' href='fn.utf8_char_width.html'>utf8_char_width</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>dstr</a>::<wbr><a class='struct' href=''>Str</a><wbr></span><span class='out-of-band'><span id='render-detail'>
            <a id="collapse-all" href="#">[-]
            </a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-513' href='../src/dstr/home/japaric/Projects/dstr/src/lib.rs.html#25'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Str(_);</pre><div class='docblock'><p>Rust&#39;s string type</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><a class='stability Unmarked' title='No stability level'></a><code>impl <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h3><div class='impl-methods'><h4 id='method.from_utf8' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.from_utf8' class='fnname'>from_utf8</a>&lt;'a&gt;(v: <a href='http://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;'a [</a><a href='http://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a href='http://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;'a <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>&gt;</code></h4>
<div class='docblock'><p>Converts a vector to a string slice without performing any allocations.</p>

<p>Once the slice has been validated as utf-8, it is transmuted in-place and
returned as a &#39;&amp;str&#39; instead of a &#39;&amp;[u8]&#39;</p>

<p>Returns None if the slice is not utf-8.</p>
</div><h4 id='method.contains' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.contains' class='fnname'>contains</a>(&amp;self, needle: &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if one string contains another</p>

<h1 id="arguments" class='section-header'><a
                           href="#arguments">Arguments</a></h1>
<ul>
<li>needle - The string to look for</li>
</ul>

<h1 id="example" class='section-header'><a
                           href="#example">Example</a></h1><pre class='rust '>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;bananas&quot;</span>).<span class='ident'>contains</span>(<span class='ident'>s</span>(<span class='string'>&quot;nana&quot;</span>)));
</pre>
</div><h4 id='method.contains_char' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.contains_char' class='fnname'>contains_char</a>(&amp;self, needle: <a href='http://doc.rust-lang.org/nightly/core/primitive.char.html'>char</a>) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if a string contains a char.</p>

<h1 id="arguments-1" class='section-header'><a
                           href="#arguments-1">Arguments</a></h1>
<ul>
<li>needle - The char to look for</li>
</ul>

<h1 id="example-1" class='section-header'><a
                           href="#example-1">Example</a></h1><pre class='rust '>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;hello&quot;</span>).<span class='ident'>contains_char</span>(<span class='string'>&#39;e&#39;</span>));
</pre>
</div><h4 id='method.chars' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.chars' class='fnname'>chars</a>(&amp;self) -&gt; <a class='struct' href='../dstr/struct.Chars.html' title='dstr::Chars'>Chars</a></code></h4>
<div class='docblock'><p>An iterator over the characters of <code>self</code>. Note, this iterates
over Unicode code-points, not Unicode graphemes.</p>

<h1 id="example-2" class='section-header'><a
                           href="#example-2">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>char</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;abc åäö&quot;</span>).<span class='ident'>chars</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&#39;a&#39;</span>, <span class='string'>&#39;b&#39;</span>, <span class='string'>&#39;c&#39;</span>, <span class='string'>&#39; &#39;</span>, <span class='string'>&#39;å&#39;</span>, <span class='string'>&#39;ä&#39;</span>, <span class='string'>&#39;ö&#39;</span>]);
</pre>
</div><h4 id='method.bytes' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.bytes' class='fnname'>bytes</a>(&amp;self) -&gt; <a class='type' href='../dstr/type.Bytes.html' title='dstr::Bytes'>Bytes</a></code></h4>
<div class='docblock'><p>An iterator over the bytes of <code>self</code></p>

<h1 id="example-3" class='section-header'><a
                           href="#example-3">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;bors&quot;</span>).<span class='ident'>bytes</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='string'>b&quot;bors&quot;</span>.<span class='ident'>to_vec</span>());
</pre>
</div><h4 id='method.char_indices' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.char_indices' class='fnname'>char_indices</a>(&amp;self) -&gt; <a class='struct' href='../dstr/struct.CharOffsets.html' title='dstr::CharOffsets'>CharOffsets</a></code></h4>
<div class='docblock'><p>An iterator over the characters of <code>self</code> and their byte offsets.</p>
</div><h4 id='method.split' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.split' class='fnname'>split</a>&lt;Sep: <a class='trait' href='http://doc.rust-lang.org/nightly/core/str/trait.CharEq.html' title='core::str::CharEq'>CharEq</a>&gt;(&amp;self, sep: Sep) -&gt; <a class='struct' href='../dstr/struct.CharSplits.html' title='dstr::CharSplits'>CharSplits</a>&lt;Sep&gt;</code></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by <code>sep</code>.</p>

<h1 id="example-4" class='section-header'><a
                           href="#example-4">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Mary had a little lamb&quot;</span>).<span class='ident'>split</span>(<span class='string'>&#39; &#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;Mary&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;had&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;a&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;little&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;lamb&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;abc1def2ghi&quot;</span>).<span class='ident'>split</span>(<span class='op'>|</span><span class='ident'>c</span>: <span class='ident'>char</span><span class='op'>|</span> <span class='ident'>c</span>.<span class='ident'>is_digit</span>()).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;abc&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;def&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;ghi&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;lionXXtigerXleopard&quot;</span>).<span class='ident'>split</span>(<span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;lion&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;tiger&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;leopard&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>).<span class='ident'>split</span>(<span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>)]);
</pre>
</div><h4 id='method.splitn' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.splitn' class='fnname'>splitn</a>&lt;Sep: <a class='trait' href='http://doc.rust-lang.org/nightly/core/str/trait.CharEq.html' title='core::str::CharEq'>CharEq</a>&gt;(&amp;self, count: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>, sep: Sep) -&gt; <a class='struct' href='../dstr/struct.CharSplitsN.html' title='dstr::CharSplitsN'>CharSplitsN</a>&lt;Sep&gt;</code></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by <code>sep</code>, restricted to splitting at most <code>count</code>
times.</p>

<h1 id="example-5" class='section-header'><a
                           href="#example-5">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Mary had a little lambda&quot;</span>).<span class='ident'>splitn</span>(<span class='number'>2</span>, <span class='string'>&#39; &#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;Mary&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;had&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;a little lambda&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;abc1def2ghi&quot;</span>).<span class='ident'>splitn</span>(<span class='number'>1</span>, <span class='op'>|</span><span class='ident'>c</span>: <span class='ident'>char</span><span class='op'>|</span> <span class='ident'>c</span>.<span class='ident'>is_digit</span>()).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;abc&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;def2ghi&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;lionXXtigerXleopard&quot;</span>).<span class='ident'>splitn</span>(<span class='number'>2</span>, <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;lion&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;tigerXleopard&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;abcXdef&quot;</span>).<span class='ident'>splitn</span>(<span class='number'>0</span>, <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;abcXdef&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>).<span class='ident'>splitn</span>(<span class='number'>1</span>, <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>)]);
</pre>
</div><h4 id='method.split_terminator' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.split_terminator' class='fnname'>split_terminator</a>&lt;Sep: <a class='trait' href='http://doc.rust-lang.org/nightly/core/str/trait.CharEq.html' title='core::str::CharEq'>CharEq</a>&gt;(&amp;self, sep: Sep) -&gt; <a class='struct' href='../dstr/struct.CharSplits.html' title='dstr::CharSplits'>CharSplits</a>&lt;Sep&gt;</code></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by <code>sep</code>.</p>

<p>Equivalent to <code>split</code>, except that the trailing substring
is skipped if empty (terminator semantics).</p>

<h1 id="example-6" class='section-header'><a
                           href="#example-6">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;A.B.&quot;</span>).<span class='ident'>split_terminator</span>(<span class='string'>&#39;.&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;A&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;B&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;A..B..&quot;</span>).<span class='ident'>split_terminator</span>(<span class='string'>&#39;.&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;A&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;B&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Mary had a little lamb&quot;</span>).<span class='ident'>split</span>(<span class='string'>&#39; &#39;</span>).<span class='ident'>rev</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;lamb&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;little&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;a&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;had&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;Mary&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;abc1def2ghi&quot;</span>).<span class='ident'>split</span>(<span class='op'>|</span><span class='ident'>c</span>: <span class='ident'>char</span><span class='op'>|</span> <span class='ident'>c</span>.<span class='ident'>is_digit</span>()).<span class='ident'>rev</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;ghi&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;def&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;abc&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;lionXXtigerXleopard&quot;</span>).<span class='ident'>split</span>(<span class='string'>&#39;X&#39;</span>).<span class='ident'>rev</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;leopard&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;tiger&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;lion&quot;</span>)]);
</pre>
</div><h4 id='method.rsplitn' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.rsplitn' class='fnname'>rsplitn</a>&lt;Sep: <a class='trait' href='http://doc.rust-lang.org/nightly/core/str/trait.CharEq.html' title='core::str::CharEq'>CharEq</a>&gt;(&amp;self, count: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>, sep: Sep) -&gt; <a class='struct' href='../dstr/struct.CharSplitsN.html' title='dstr::CharSplitsN'>CharSplitsN</a>&lt;Sep&gt;</code></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by <code>sep</code>, starting from the end of the string.
Restricted to splitting at most <code>count</code> times.</p>

<h1 id="example-7" class='section-header'><a
                           href="#example-7">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Mary had a little lamb&quot;</span>).<span class='ident'>rsplitn</span>(<span class='number'>2</span>, <span class='string'>&#39; &#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;lamb&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;little&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;Mary had a&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;abc1def2ghi&quot;</span>).<span class='ident'>rsplitn</span>(<span class='number'>1</span>, <span class='op'>|</span><span class='ident'>c</span>: <span class='ident'>char</span><span class='op'>|</span> <span class='ident'>c</span>.<span class='ident'>is_digit</span>()).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;ghi&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;abc1def&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;lionXXtigerXleopard&quot;</span>).<span class='ident'>rsplitn</span>(<span class='number'>2</span>, <span class='string'>&#39;X&#39;</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;leopard&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;tiger&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;lionX&quot;</span>)]);
</pre>
</div><h4 id='method.match_indices' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.match_indices' class='fnname'>match_indices</a>&lt;'a&gt;(&amp;'a self, sep: &amp;'a <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a class='struct' href='../dstr/struct.MatchIndices.html' title='dstr::MatchIndices'>MatchIndices</a>&lt;'a&gt;</code></h4>
<div class='docblock'><p>An iterator over the start and end indices of the disjoint
matches of <code>sep</code> within <code>self</code>.</p>

<p>That is, each returned value <code>(start, end)</code> satisfies
<code>self.slice(start, end) == sep</code>. For matches of <code>sep</code> within
<code>self</code> that overlap, only the indices corresponding to the
first match are returned.</p>

<h1 id="example-8" class='section-header'><a
                           href="#example-8">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>(<span class='ident'>uint</span>, <span class='ident'>uint</span>)<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;abcXXXabcYYYabc&quot;</span>).<span class='ident'>match_indices</span>(<span class='ident'>s</span>(<span class='string'>&quot;abc&quot;</span>)).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='number'>0</span>,<span class='number'>3</span>), (<span class='number'>6</span>,<span class='number'>9</span>), (<span class='number'>12</span>,<span class='number'>15</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>(<span class='ident'>uint</span>, <span class='ident'>uint</span>)<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;1abcabc2&quot;</span>).<span class='ident'>match_indices</span>(<span class='ident'>s</span>(<span class='string'>&quot;abc&quot;</span>)).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='number'>1</span>,<span class='number'>4</span>), (<span class='number'>4</span>,<span class='number'>7</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>(<span class='ident'>uint</span>, <span class='ident'>uint</span>)<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;ababa&quot;</span>).<span class='ident'>match_indices</span>(<span class='ident'>s</span>(<span class='string'>&quot;aba&quot;</span>)).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='number'>0</span>, <span class='number'>3</span>)]); <span class='comment'>// only the first `aba`</span>
</pre>
</div><h4 id='method.split_str' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.split_str' class='fnname'>split_str</a>&lt;'a&gt;(&amp;'a self, sep: &amp;'a <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a class='struct' href='../dstr/struct.StrSplits.html' title='dstr::StrSplits'>StrSplits</a>&lt;'a&gt;</code></h4>
<div class='docblock'><p>An iterator over the substrings of <code>self</code> separated by <code>sep</code>.</p>

<h1 id="example-9" class='section-header'><a
                           href="#example-9">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;abcXXXabcYYYabc&quot;</span>).<span class='ident'>split_str</span>(<span class='ident'>s</span>(<span class='string'>&quot;abc&quot;</span>)).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;XXX&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;YYY&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>)]);

<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;1abcabc2&quot;</span>).<span class='ident'>split_str</span>(<span class='ident'>s</span>(<span class='string'>&quot;abc&quot;</span>)).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;1&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;2&quot;</span>)]);
</pre>
</div><h4 id='method.lines' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.lines' class='fnname'>lines</a>(&amp;self) -&gt; <a class='struct' href='../dstr/struct.CharSplits.html' title='dstr::CharSplits'>CharSplits</a>&lt;<a href='http://doc.rust-lang.org/nightly/core/primitive.char.html'>char</a>&gt;</code></h4>
<div class='docblock'><p>An iterator over the lines of a string (subsequences separated
by <code>\n</code>). This does not include the empty string after a
trailing <code>\n</code>.</p>

<h1 id="example-10" class='section-header'><a
                           href="#example-10">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>four_lines</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;foo\nbar\n\nbaz\n&quot;</span>);
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>four_lines</span>.<span class='ident'>lines</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;foo&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;bar&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;baz&quot;</span>)]);
</pre>
</div><h4 id='method.lines_any' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.lines_any' class='fnname'>lines_any</a>(&amp;self) -&gt; <a class='type' href='../dstr/type.AnyLines.html' title='dstr::AnyLines'>AnyLines</a></code></h4>
<div class='docblock'><p>An iterator over the lines of a string, separated by either
<code>\n</code> or <code>\r\n</code>. As with <code>.lines()</code>, this does not include an
empty trailing line.</p>

<h1 id="example-11" class='section-header'><a
                           href="#example-11">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>four_lines</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;foo\r\nbar\n\r\nbaz\n&quot;</span>);
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>four_lines</span>.<span class='ident'>lines_any</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>v</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>s</span>(<span class='string'>&quot;foo&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;bar&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>), <span class='ident'>s</span>(<span class='string'>&quot;baz&quot;</span>)]);
</pre>
</div><h4 id='method.char_len' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.char_len' class='fnname'>char_len</a>(&amp;self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a></code></h4>
<div class='docblock'><p>Returns the number of Unicode code points (<code>char</code>) that a
string holds.</p>

<p>This does not perform any normalization, and is <code>O(n)</code>, since
UTF-8 is a variable width encoding of code points.</p>

<p><em>Warning</em>: The number of code points in a string does not directly
correspond to the number of visible characters or width of the
visible text due to composing characters, and double- and
zero-width ones.</p>

<p>See also <code>.len()</code> for the byte length.</p>

<h1 id="example-12" class='section-header'><a
                           href="#example-12">Example</a></h1><pre class='rust '>
<span class='comment'>// composed forms of `ö` and `é`</span>
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>); <span class='comment'>// German, Simplified Chinese, French</span>
<span class='comment'>// decomposed forms of `ö` and `é`</span>
<span class='kw'>let</span> <span class='ident'>d</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Lo\u0308we 老虎 Le\u0301opard&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>c</span>.<span class='ident'>char_len</span>(), <span class='number'>15</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>d</span>.<span class='ident'>char_len</span>(), <span class='number'>17</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>c</span>.<span class='ident'>len</span>(), <span class='number'>21</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>d</span>.<span class='ident'>len</span>(), <span class='number'>23</span>);

<span class='comment'>// the two strings *look* the same</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>c</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>d</span>);
</pre>
</div><h4 id='method.slice' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.slice' class='fnname'>slice</a>(&amp;self, begin: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>, end: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
<div class='docblock'><p>Returns a slice of the given string from the byte range
[<code>begin</code>..<code>end</code>).</p>

<p>This operation is <code>O(1)</code>.</p>

<p>Panics when <code>begin</code> and <code>end</code> do not point to valid characters
or point beyond the last character of the string.</p>

<p>See also <code>slice_to</code> and <code>slice_from</code> for slicing prefixes and
suffixes of strings, and <code>slice_chars</code> for slicing based on
code point counts.</p>

<h1 id="example-13" class='section-header'><a
                           href="#example-13">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>st</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>slice</span>(<span class='number'>0</span>, <span class='number'>1</span>), <span class='ident'>s</span>(<span class='string'>&quot;L&quot;</span>));

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>slice</span>(<span class='number'>1</span>, <span class='number'>9</span>), <span class='ident'>s</span>(<span class='string'>&quot;öwe 老&quot;</span>));

<span class='comment'>// these will panic:</span>
<span class='comment'>// byte 2 lies within `ö`:</span>
<span class='comment'>// s.slice(2, 3);</span>

<span class='comment'>// byte 8 lies within `老`</span>
<span class='comment'>// s.slice(1, 8);</span>

<span class='comment'>// byte 100 is outside the string</span>
<span class='comment'>// s.slice(3, 100);</span>
</pre>
</div><h4 id='method.slice_from' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.slice_from' class='fnname'>slice_from</a>(&amp;self, begin: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
<div class='docblock'><p>Returns a slice of the string from <code>begin</code> to its end.</p>

<p>Equivalent to <code>self.slice(begin, self.len())</code>.</p>

<p>Panics when <code>begin</code> does not point to a valid character, or is
out of bounds.</p>

<p>See also <code>slice</code>, <code>slice_to</code> and <code>slice_chars</code>.</p>
</div><h4 id='method.slice_to' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.slice_to' class='fnname'>slice_to</a>(&amp;self, end: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
<div class='docblock'><p>Returns a slice of the string from the beginning to byte
<code>end</code>.</p>

<p>Equivalent to <code>self.slice(0, end)</code>.</p>

<p>Panics when <code>end</code> does not point to a valid character, or is
out of bounds.</p>

<p>See also <code>slice</code>, <code>slice_from</code> and <code>slice_chars</code>.</p>
</div><h4 id='method.slice_chars' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.slice_chars' class='fnname'>slice_chars</a>(&amp;self, begin: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>, end: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
<div class='docblock'><p>Returns a slice of the string from the character range
[<code>begin</code>..<code>end</code>).</p>

<p>That is, start at the <code>begin</code>-th code point of the string and
continue to the <code>end</code>-th code point. This does not detect or
handle edge cases such as leaving a combining character as the
first code point of the string.</p>

<p>Due to the design of UTF-8, this operation is <code>O(end)</code>.
See <code>slice</code>, <code>slice_to</code> and <code>slice_from</code> for <code>O(1)</code>
variants that use byte indices rather than code point
indices.</p>

<p>Panics if <code>begin</code> &gt; <code>end</code> or the either <code>begin</code> or <code>end</code> are
beyond the last character of the string.</p>

<h1 id="example-14" class='section-header'><a
                           href="#example-14">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>st</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>slice_chars</span>(<span class='number'>0</span>, <span class='number'>4</span>), <span class='ident'>s</span>(<span class='string'>&quot;Löwe&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>slice_chars</span>(<span class='number'>5</span>, <span class='number'>7</span>), <span class='ident'>s</span>(<span class='string'>&quot;老虎&quot;</span>));
</pre>
</div><h4 id='method.starts_with' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.starts_with' class='fnname'>starts_with</a>(&amp;self, needle: &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if <code>needle</code> is a prefix of the string.</p>

<h1 id="example-15" class='section-header'><a
                           href="#example-15">Example</a></h1><pre class='rust '>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;banana&quot;</span>).<span class='ident'>starts_with</span>(<span class='ident'>s</span>(<span class='string'>&quot;ba&quot;</span>)));
</pre>
</div><h4 id='method.ends_with' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.ends_with' class='fnname'>ends_with</a>(&amp;self, needle: &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if <code>needle</code> is a suffix of the string.</p>

<h1 id="example-16" class='section-header'><a
                           href="#example-16">Example</a></h1><pre class='rust '>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;banana&quot;</span>).<span class='ident'>ends_with</span>(<span class='ident'>s</span>(<span class='string'>&quot;nana&quot;</span>)));
</pre>
</div><h4 id='method.trim_chars' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.trim_chars' class='fnname'>trim_chars</a>&lt;C: <a class='trait' href='http://doc.rust-lang.org/nightly/core/str/trait.CharEq.html' title='core::str::CharEq'>CharEq</a>&gt;(&amp;self, to_trim: C) -&gt; &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
<div class='docblock'><p>Returns a string with characters that match <code>to_trim</code> removed from the left and the right.</p>

<h1 id="arguments-2" class='section-header'><a
                           href="#arguments-2">Arguments</a></h1>
<ul>
<li>to_trim - a character matcher</li>
</ul>

<h1 id="example-17" class='section-header'><a
                           href="#example-17">Example</a></h1><pre class='rust '>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;11foo1bar11&quot;</span>).<span class='ident'>trim_chars</span>(<span class='string'>&#39;1&#39;</span>), <span class='ident'>s</span>(<span class='string'>&quot;foo1bar&quot;</span>))
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[_] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&#39;1&#39;</span>, <span class='string'>&#39;2&#39;</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;12foo1bar12&quot;</span>).<span class='ident'>trim_chars</span>(<span class='ident'>x</span>), <span class='ident'>s</span>(<span class='string'>&quot;foo1bar&quot;</span>))
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;123foo1bar123&quot;</span>).<span class='ident'>trim_chars</span>(<span class='op'>|</span><span class='ident'>c</span>: <span class='ident'>char</span><span class='op'>|</span> <span class='ident'>c</span>.<span class='ident'>is_digit</span>()), <span class='ident'>s</span>(<span class='string'>&quot;foo1bar&quot;</span>))
</pre>
</div><h4 id='method.trim_left_chars' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.trim_left_chars' class='fnname'>trim_left_chars</a>&lt;C: <a class='trait' href='http://doc.rust-lang.org/nightly/core/str/trait.CharEq.html' title='core::str::CharEq'>CharEq</a>&gt;(&amp;self, to_trim: C) -&gt; &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
<div class='docblock'><p>Returns a string with leading <code>chars_to_trim</code> removed.</p>

<h1 id="arguments-3" class='section-header'><a
                           href="#arguments-3">Arguments</a></h1>
<ul>
<li>to_trim - a character matcher</li>
</ul>

<h1 id="example-18" class='section-header'><a
                           href="#example-18">Example</a></h1><pre class='rust '>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;11foo1bar11&quot;</span>).<span class='ident'>trim_left_chars</span>(<span class='string'>&#39;1&#39;</span>), <span class='ident'>s</span>(<span class='string'>&quot;foo1bar11&quot;</span>))
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[_] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&#39;1&#39;</span>, <span class='string'>&#39;2&#39;</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;12foo1bar12&quot;</span>).<span class='ident'>trim_left_chars</span>(<span class='ident'>x</span>), <span class='ident'>s</span>(<span class='string'>&quot;foo1bar12&quot;</span>))
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;123foo1bar123&quot;</span>).<span class='ident'>trim_left_chars</span>(<span class='op'>|</span><span class='ident'>c</span>: <span class='ident'>char</span><span class='op'>|</span> <span class='ident'>c</span>.<span class='ident'>is_digit</span>()), <span class='ident'>s</span>(<span class='string'>&quot;foo1bar123&quot;</span>))
</pre>
</div><h4 id='method.trim_right_chars' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.trim_right_chars' class='fnname'>trim_right_chars</a>&lt;C: <a class='trait' href='http://doc.rust-lang.org/nightly/core/str/trait.CharEq.html' title='core::str::CharEq'>CharEq</a>&gt;(&amp;self, to_trim: C) -&gt; &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
<div class='docblock'><p>Returns a string with trailing <code>chars_to_trim</code> removed.</p>

<h1 id="arguments-4" class='section-header'><a
                           href="#arguments-4">Arguments</a></h1>
<ul>
<li>to_trim - a character matcher</li>
</ul>

<h1 id="example-19" class='section-header'><a
                           href="#example-19">Example</a></h1><pre class='rust '>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;11foo1bar11&quot;</span>).<span class='ident'>trim_right_chars</span>(<span class='string'>&#39;1&#39;</span>), <span class='ident'>s</span>(<span class='string'>&quot;11foo1bar&quot;</span>))
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[_] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&#39;1&#39;</span>, <span class='string'>&#39;2&#39;</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;12foo1bar12&quot;</span>).<span class='ident'>trim_right_chars</span>(<span class='ident'>x</span>), <span class='ident'>s</span>(<span class='string'>&quot;12foo1bar&quot;</span>))
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;123foo1bar123&quot;</span>).<span class='ident'>trim_right_chars</span>(<span class='op'>|</span><span class='ident'>c</span>: <span class='ident'>char</span><span class='op'>|</span> <span class='ident'>c</span>.<span class='ident'>is_digit</span>()), <span class='ident'>s</span>(<span class='string'>&quot;123foo1bar&quot;</span>))
</pre>
</div><h4 id='method.is_char_boundary' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.is_char_boundary' class='fnname'>is_char_boundary</a>(&amp;self, index: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Check that <code>index</code>-th byte lies at the start and/or end of a
UTF-8 code point sequence.</p>

<p>The start and end of the string (when <code>index == self.len()</code>)
are considered to be boundaries.</p>

<p>Panics if <code>index</code> is greater than <code>self.len()</code>.</p>

<h1 id="example-20" class='section-header'><a
                           href="#example-20">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>st</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>is_char_boundary</span>(<span class='number'>0</span>));
<span class='comment'>// start of `老`</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>is_char_boundary</span>(<span class='number'>6</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>is_char_boundary</span>(<span class='ident'>st</span>.<span class='ident'>len</span>()));

<span class='comment'>// second byte of `ö`</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>st</span>.<span class='ident'>is_char_boundary</span>(<span class='number'>2</span>));

<span class='comment'>// third byte of `老`</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>st</span>.<span class='ident'>is_char_boundary</span>(<span class='number'>8</span>));
</pre>
</div><h4 id='method.char_range_at' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.char_range_at' class='fnname'>char_range_at</a>(&amp;self, i: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; <a class='struct' href='../dstr/struct.CharRange.html' title='dstr::CharRange'>CharRange</a></code></h4>
<div class='docblock'><p>Pluck a character out of a string and return the index of the next
character.</p>

<p>This function can be used to iterate over the Unicode characters of a
string.</p>

<h1 id="example-21" class='section-header'><a
                           href="#example-21">Example</a></h1>
<p>This example manually iterates through the characters of a
string; this should normally be done by <code>.chars()</code> or
<code>.char_indices</code>.</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>dstr</span>::<span class='ident'>CharRange</span>;

<span class='kw'>let</span> <span class='ident'>st</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;中华Việt Nam&quot;</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>0u</span>;
<span class='kw'>while</span> <span class='ident'>i</span> <span class='op'>&lt;</span> <span class='ident'>st</span>.<span class='ident'>len</span>() {
    <span class='kw'>let</span> <span class='ident'>CharRange</span> {<span class='ident'>ch</span>, <span class='ident'>next</span>} <span class='op'>=</span> <span class='ident'>st</span>.<span class='ident'>char_range_at</span>(<span class='ident'>i</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}: {}&quot;</span>, <span class='ident'>i</span>, <span class='ident'>ch</span>);
    <span class='ident'>i</span> <span class='op'>=</span> <span class='ident'>next</span>;
}
</pre>

<h2 id="output" class='section-header'><a
                           href="#output">Output</a></h2><pre class='rust '>
<span class='number'>0</span>: <span class='ident'>中</span>
<span class='number'>3</span>: <span class='ident'>华</span>
<span class='number'>6</span>: <span class='ident'>V</span>
<span class='number'>7</span>: <span class='ident'>i</span>
<span class='number'>8</span>: <span class='ident'>ệ</span>
<span class='number'>11</span>: <span class='ident'>t</span>
<span class='number'>12</span>:
<span class='number'>13</span>: <span class='ident'>N</span>
<span class='number'>14</span>: <span class='ident'>a</span>
<span class='number'>15</span>: <span class='ident'>m</span>
</pre>

<h1 id="arguments-5" class='section-header'><a
                           href="#arguments-5">Arguments</a></h1>
<ul>
<li>s - The string</li>
<li>i - The byte offset of the char to extract</li>
</ul>

<h1 id="return-value" class='section-header'><a
                           href="#return-value">Return value</a></h1>
<p>A record {ch: char, next: uint} containing the char value and the byte
index of the next Unicode character.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>If <code>i</code> is greater than or equal to the length of the string.
If <code>i</code> is not the index of the beginning of a valid UTF-8 character.</p>
</div><h4 id='method.char_range_at_reverse' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.char_range_at_reverse' class='fnname'>char_range_at_reverse</a>(&amp;self, start: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; <a class='struct' href='../dstr/struct.CharRange.html' title='dstr::CharRange'>CharRange</a></code></h4>
<div class='docblock'><p>Given a byte position and a str, return the previous char and its position.</p>

<p>This function can be used to iterate over a Unicode string in reverse.</p>

<p>Returns 0 for next index if called on start index 0.</p>

<h1 id="panics-1" class='section-header'><a
                           href="#panics-1">Panics</a></h1>
<p>If <code>i</code> is greater than the length of the string.
If <code>i</code> is not an index following a valid UTF-8 character.</p>
</div><h4 id='method.char_at' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.char_at' class='fnname'>char_at</a>(&amp;self, i: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; <a href='http://doc.rust-lang.org/nightly/core/primitive.char.html'>char</a></code></h4>
<div class='docblock'><p>Plucks the character starting at the <code>i</code>th byte of a string.</p>

<h1 id="example-22" class='section-header'><a
                           href="#example-22">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>st</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;abπc&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>char_at</span>(<span class='number'>1</span>), <span class='string'>&#39;b&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>char_at</span>(<span class='number'>2</span>), <span class='string'>&#39;π&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>char_at</span>(<span class='number'>4</span>), <span class='string'>&#39;c&#39;</span>);
</pre>

<h1 id="panics-2" class='section-header'><a
                           href="#panics-2">Panics</a></h1>
<p>If <code>i</code> is greater than or equal to the length of the string.
If <code>i</code> is not the index of the beginning of a valid UTF-8 character.</p>
</div><h4 id='method.char_at_reverse' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.char_at_reverse' class='fnname'>char_at_reverse</a>(&amp;self, i: <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; <a href='http://doc.rust-lang.org/nightly/core/primitive.char.html'>char</a></code></h4>
<div class='docblock'><p>Plucks the character ending at the <code>i</code>th byte of a string.</p>

<h1 id="panics-3" class='section-header'><a
                           href="#panics-3">Panics</a></h1>
<p>If <code>i</code> is greater than the length of the string.
If <code>i</code> is not an index following a valid UTF-8 character.</p>
</div><h4 id='method.as_bytes' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.as_bytes' class='fnname'>as_bytes</a>(&amp;self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a href='http://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a href='http://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a></code></h4>
<div class='docblock'><p>Work with the byte buffer of a string as a byte slice.</p>

<h1 id="example-23" class='section-header'><a
                           href="#example-23">Example</a></h1><pre class='rust '>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;bors&quot;</span>).<span class='ident'>as_bytes</span>(), <span class='string'>b&quot;bors&quot;</span>);
</pre>
</div><h4 id='method.find' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.find' class='fnname'>find</a>&lt;C: <a class='trait' href='http://doc.rust-lang.org/nightly/core/str/trait.CharEq.html' title='core::str::CharEq'>CharEq</a>&gt;(&amp;self, search: C) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>&gt;</code></h4>
<div class='docblock'><p>Returns the byte index of the first character of <code>self</code> that
matches <code>search</code>.</p>

<h1 id="return-value-1" class='section-header'><a
                           href="#return-value-1">Return value</a></h1>
<p><code>Some</code> containing the byte index of the last matching character
or <code>None</code> if there is no match</p>

<h1 id="example-24" class='section-header'><a
                           href="#example-24">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&#39;L&#39;</span>), <span class='prelude-val'>Some</span>(<span class='number'>0</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&#39;é&#39;</span>), <span class='prelude-val'>Some</span>(<span class='number'>14</span>));

<span class='comment'>// the first space</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='op'>|</span><span class='ident'>c</span>: <span class='ident'>char</span><span class='op'>|</span> <span class='ident'>c</span>.<span class='ident'>is_whitespace</span>()), <span class='prelude-val'>Some</span>(<span class='number'>5</span>));

<span class='comment'>// neither are found</span>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[_] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&#39;1&#39;</span>, <span class='string'>&#39;2&#39;</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>find</span>(<span class='ident'>x</span>), <span class='prelude-val'>None</span>);
</pre>
</div><h4 id='method.rfind' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.rfind' class='fnname'>rfind</a>&lt;C: <a class='trait' href='http://doc.rust-lang.org/nightly/core/str/trait.CharEq.html' title='core::str::CharEq'>CharEq</a>&gt;(&amp;self, search: C) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>&gt;</code></h4>
<div class='docblock'><p>Returns the byte index of the last character of <code>self</code> that
matches <code>search</code>.</p>

<h1 id="return-value-2" class='section-header'><a
                           href="#return-value-2">Return value</a></h1>
<p><code>Some</code> containing the byte index of the last matching character
or <code>None</code> if there is no match.</p>

<h1 id="example-25" class='section-header'><a
                           href="#example-25">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>rfind</span>(<span class='string'>&#39;L&#39;</span>), <span class='prelude-val'>Some</span>(<span class='number'>13</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>rfind</span>(<span class='string'>&#39;é&#39;</span>), <span class='prelude-val'>Some</span>(<span class='number'>14</span>));

<span class='comment'>// the second space</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>rfind</span>(<span class='op'>|</span><span class='ident'>c</span>: <span class='ident'>char</span><span class='op'>|</span> <span class='ident'>c</span>.<span class='ident'>is_whitespace</span>()), <span class='prelude-val'>Some</span>(<span class='number'>12</span>));

<span class='comment'>// searches for an occurrence of either `1` or `2`, but neither are found</span>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[_] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>&#39;1&#39;</span>, <span class='string'>&#39;2&#39;</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>rfind</span>(<span class='ident'>x</span>), <span class='prelude-val'>None</span>);
</pre>
</div><h4 id='method.find_str' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.find_str' class='fnname'>find_str</a>(&amp;self, needle: &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>&gt;</code></h4>
<div class='docblock'><p>Returns the byte index of the first matching substring</p>

<h1 id="arguments-6" class='section-header'><a
                           href="#arguments-6">Arguments</a></h1>
<ul>
<li><code>needle</code> - The string to search for</li>
</ul>

<h1 id="return-value-3" class='section-header'><a
                           href="#return-value-3">Return value</a></h1>
<p><code>Some</code> containing the byte index of the first matching substring
or <code>None</code> if there is no match.</p>

<h1 id="example-26" class='section-header'><a
                           href="#example-26">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>st</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>find_str</span>(<span class='ident'>s</span>(<span class='string'>&quot;老虎 L&quot;</span>)), <span class='prelude-val'>Some</span>(<span class='number'>6</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>st</span>.<span class='ident'>find_str</span>(<span class='ident'>s</span>(<span class='string'>&quot;muffin man&quot;</span>)), <span class='prelude-val'>None</span>);
</pre>
</div><h4 id='method.slice_shift_char' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.slice_shift_char' class='fnname'>slice_shift_char</a>(&amp;self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a href='http://doc.rust-lang.org/nightly/core/primitive.char.html'>char</a>&gt;, &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>)</a></code></h4>
<div class='docblock'><p>Retrieves the first character from a string slice and returns
it. This does not allocate a new string; instead, it returns a
slice that point one character beyond the character that was
shifted. If the string does not contain any characters,
a tuple of None and an empty string is returned instead.</p>

<h1 id="example-27" class='section-header'><a
                           href="#example-27">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>st</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;Löwe 老虎 Léopard&quot;</span>);
<span class='kw'>let</span> (<span class='ident'>c</span>, <span class='ident'>s1</span>) <span class='op'>=</span> <span class='ident'>st</span>.<span class='ident'>slice_shift_char</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>c</span>, <span class='prelude-val'>Some</span>(<span class='string'>&#39;L&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s1</span>, <span class='ident'>s</span>(<span class='string'>&quot;öwe 老虎 Léopard&quot;</span>));

<span class='kw'>let</span> (<span class='ident'>c</span>, <span class='ident'>s2</span>) <span class='op'>=</span> <span class='ident'>s1</span>.<span class='ident'>slice_shift_char</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>c</span>, <span class='prelude-val'>Some</span>(<span class='string'>&#39;ö&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s2</span>, <span class='ident'>s</span>(<span class='string'>&quot;we 老虎 Léopard&quot;</span>));
</pre>
</div><h4 id='method.subslice_offset' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.subslice_offset' class='fnname'>subslice_offset</a>(&amp;self, inner: &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a></code></h4>
<div class='docblock'><p>Returns the byte offset of an inner slice relative to an enclosing outer slice.</p>

<p>Panics if <code>inner</code> is not a direct slice contained within self.</p>

<h1 id="example-28" class='section-header'><a
                           href="#example-28">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>string</span> <span class='op'>=</span> <span class='ident'>s</span>(<span class='string'>&quot;a\nb\nc&quot;</span>);
<span class='kw'>let</span> <span class='ident'>lines</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>string</span>.<span class='ident'>lines</span>().<span class='ident'>collect</span>();
<span class='kw'>let</span> <span class='ident'>lines</span> <span class='op'>=</span> <span class='ident'>lines</span>.<span class='ident'>as_slice</span>();

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>string</span>.<span class='ident'>subslice_offset</span>(<span class='ident'>lines</span>[<span class='number'>0</span>]) <span class='op'>==</span> <span class='number'>0</span>); <span class='comment'>// &amp;&quot;a&quot;</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>string</span>.<span class='ident'>subslice_offset</span>(<span class='ident'>lines</span>[<span class='number'>1</span>]) <span class='op'>==</span> <span class='number'>2</span>); <span class='comment'>// &amp;&quot;b&quot;</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>string</span>.<span class='ident'>subslice_offset</span>(<span class='ident'>lines</span>[<span class='number'>2</span>]) <span class='op'>==</span> <span class='number'>4</span>); <span class='comment'>// &amp;&quot;c&quot;</span>
</pre>
</div><h4 id='method.as_ptr' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.as_ptr' class='fnname'>as_ptr</a>(&amp;self) -&gt; *const <a href='http://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a></code></h4>
<div class='docblock'><p>Return an unsafe pointer to the strings buffer.</p>

<p>The caller must ensure that the string outlives this pointer,
and that it is not reallocated (e.g. by pushing to the
string).</p>
</div><h4 id='method.utf16_units' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.utf16_units' class='fnname'>utf16_units</a>(&amp;self) -&gt; <a class='struct' href='../dstr/struct.Utf16CodeUnits.html' title='dstr::Utf16CodeUnits'>Utf16CodeUnits</a></code></h4>
<div class='docblock'><p>Return an iterator of <code>u16</code> over the string encoded as UTF-16.</p>
</div><h4 id='method.len' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a></code></h4>
<div class='docblock'><p>Return the number of bytes in this string</p>

<h1 id="example-29" class='section-header'><a
                           href="#example-29">Example</a></h1><pre class='rust '>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;foo&quot;</span>).<span class='ident'>len</span>(), <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;ƒoo&quot;</span>).<span class='ident'>len</span>(), <span class='number'>4</span>);
</pre>
</div><h4 id='method.is_empty' class='method'><a class='stability Experimental' title='Experimental: not triaged yet'></a><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if this slice contains no bytes</p>

<h1 id="example-30" class='section-header'><a
                           href="#example-30">Example</a></h1><pre class='rust '>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>(<span class='string'>&quot;&quot;</span>).<span class='ident'>is_empty</span>());
</pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><a class='stability Unmarked' title='No stability level'></a><code>impl <a class='trait' href='http://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html' title='core::cmp::Ord'>Ord</a> for <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h3><div class='impl-methods'><h4 id='method.cmp' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.cmp' class='fnname'>cmp</a>(&amp;self, other: &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></code></h4>
</div><h3 class='impl'><a class='stability Unmarked' title='No stability level'></a><code>impl <a class='trait' href='http://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a> for <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h3><div class='impl-methods'><h4 id='method.eq' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ne' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><a class='stability Unmarked' title='No stability level'></a><code>impl <a class='trait' href='http://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a> for <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h3><div class='impl-methods'><h4 id='method.assert_receiver_is_total_eq' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#tymethod.assert_receiver_is_total_eq' class='fnname'>assert_receiver_is_total_eq</a>(&amp;self)</code></h4>
</div><h3 class='impl'><a class='stability Unmarked' title='No stability level'></a><code>impl <a class='trait' href='http://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html' title='core::cmp::PartialOrd'>PartialOrd</a> for <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h3><div class='impl-methods'><h4 id='method.partial_cmp' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, other: &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>) -&gt; <a class='enum' href='http://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='enum' href='http://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a>&gt;</code></h4>
<h4 id='method.lt' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#tymethod.lt' class='fnname'>lt</a>(&amp;self, other: &amp;Self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.le' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#tymethod.le' class='fnname'>le</a>(&amp;self, other: &amp;Self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.gt' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#tymethod.gt' class='fnname'>gt</a>(&amp;self, other: &amp;Self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ge' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#tymethod.ge' class='fnname'>ge</a>(&amp;self, other: &amp;Self) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><a class='stability Unmarked' title='No stability level'></a><code>impl&lt;S: <a class='trait' href='../dstr/trait.AsStr.html' title='dstr::AsStr'>AsStr</a>&gt; <a class='trait' href='http://doc.rust-lang.org/nightly/core/cmp/trait.Equiv.html' title='core::cmp::Equiv'>Equiv</a>&lt;S&gt; for <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h3><div class='impl-methods'><h4 id='method.equiv' class='method'><a class='stability Experimental' title='Experimental: Better solutions may be discovered.'></a><code>fn <a href='#method.equiv' class='fnname'>equiv</a>(&amp;self, other: &amp;S) -&gt; <a href='http://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><a class='stability Unmarked' title='No stability level'></a><code>impl <a class='trait' href='http://doc.rust-lang.org/nightly/core/ops/trait.Slice.html' title='core::ops::Slice'>Slice</a>&lt;<a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>, <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a>&gt; for <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h3><div class='impl-methods'><h4 id='method.as_slice_' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.as_slice_' class='fnname'>as_slice_</a>&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
<h4 id='method.slice_from_or_fail' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.slice_from_or_fail' class='fnname'>slice_from_or_fail</a>&lt;'a&gt;(&amp;'a self, from: &amp;<a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; &amp;'a <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
<h4 id='method.slice_to_or_fail' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.slice_to_or_fail' class='fnname'>slice_to_or_fail</a>&lt;'a&gt;(&amp;'a self, to: &amp;<a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; &amp;'a <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
<h4 id='method.slice_or_fail' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.slice_or_fail' class='fnname'>slice_or_fail</a>&lt;'a&gt;(&amp;'a self, from: &amp;<a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>, to: &amp;<a href='http://doc.rust-lang.org/nightly/std/primitive.uint.html'>uint</a>) -&gt; &amp;'a <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
</div><h3 class='impl'><a class='stability Unmarked' title='No stability level'></a><code>impl <a class='trait' href='http://doc.rust-lang.org/nightly/core/raw/trait.Repr.html' title='core::raw::Repr'>Repr</a>&lt;<a class='struct' href='http://doc.rust-lang.org/nightly/core/raw/struct.Slice.html' title='core::raw::Slice'>Slice</a>&lt;<a href='http://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a>&gt;&gt; for <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h3><div class='impl-methods'><h4 id='method.repr' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.repr' class='fnname'>repr</a>(&amp;self) -&gt; <a class='struct' href='http://doc.rust-lang.org/nightly/core/raw/struct.Slice.html' title='core::raw::Slice'>Slice</a>&lt;<a href='http://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a>&gt;</code></h4>
</div><h3 class='impl'><a class='stability Unmarked' title='No stability level'></a><code>impl <a class='trait' href='http://doc.rust-lang.org/nightly/core/fmt/trait.Show.html' title='core::fmt::Show'>Show</a> for <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h3><div class='impl-methods'><h4 id='method.fmt' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='http://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html' title='core::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='http://doc.rust-lang.org/nightly/core/fmt/type.Result.html' title='core::fmt::Result'>Result</a></code></h4>
</div><h3 class='impl'><a class='stability Unmarked' title='No stability level'></a><code>impl <a class='trait' href='../dstr/trait.AsStr.html' title='dstr::AsStr'>AsStr</a> for <a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h3><div class='impl-methods'><h4 id='method.as_str' class='method'><a class='stability Unmarked' title='No stability level'></a><code>fn <a href='#method.as_str' class='fnname'>as_str</a>(&amp;self) -&gt; &amp;<a class='struct' href='../dstr/struct.Str.html' title='dstr::Str'>Str</a></code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "dstr";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>