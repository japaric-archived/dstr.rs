var searchIndex = {};
searchIndex['dstr'] = {"items":[[0,"","dstr",""],[1,"Str","","Rust's string type"],[1,"CharSplits","","An iterator over the substrings of a string, separated by `sep`."],[1,"CharSplitsN","","An iterator over the substrings of a string, separated by `sep`,\nsplitting at most `count` times."],[1,"MatchIndices","","An iterator over the start and end indices of the matches of a\nsubstring within a larger string"],[1,"StrSplits","","An iterator over the substrings of a string separated by a given\nsearch string"],[1,"Chars","","Iterator for the char (representing *Unicode Scalar Values*) of a string"],[1,"CharOffsets","","External iterator for a string's characters and their byte offsets.\nUse with the `std::iter` module."],[1,"CharRange","","Struct that contains a `char` and the index of the first byte of\nthe next `char` in a string.  This can be used as a data structure\nfor iterating over the UTF-8 bytes of a string."],[11,"ch","","Current `char`",0],[11,"next","","Index of the first byte of the next `char`",0],[1,"Utf16CodeUnits","","External iterator for a string's UTF16 codeunits.\nUse with the `std::iter` module."],[3,"s","",""],[3,"eq_slice","","Bytewise slice equality\nNOTE: This function is (ab)used in rustc::middle::trans::_match\nto compare &[u8] byte slices that are not necessarily valid UTF-8."],[3,"is_utf8","","Determines if a vector of bytes contains valid UTF-8."],[3,"utf8_char_width","","Given a first byte, determine how many bytes are in this UTF-8 character"],[10,"cmp","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"partial_cmp","","",1],[10,"equiv","","",1],[10,"as_slice_","","",1],[10,"slice_from_or_fail","","",1],[10,"slice_to_or_fail","","",1],[10,"slice_or_fail","","",1],[0,"raw","",""],[3,"from_utf8","dstr::raw","Converts a slice of bytes to a string slice without checking\nthat the string contains valid UTF-8."],[3,"c_str_to_static_slice","","Form a slice from a C string. Unsafe because the caller must ensure the\nC string has the static lifetime, or else the return value may be\ninvalidated later."],[3,"slice_bytes","","Takes a bytewise (not UTF-8) slice from a string."],[3,"slice_unchecked","","Takes a bytewise (not UTF-8) slice from a string."],[4,"AnyLines","dstr","An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`)."],[4,"Bytes","","External iterator for a string's bytes.\nUse with the `std::iter` module."],[6,"AsStr","",""],[9,"as_str","","",2],[10,"repr","","",1],[10,"fmt","","",1],[10,"as_str","","",1],[10,"from_utf8","","Converts a vector to a string slice without performing any allocations.",1],[10,"contains","","Returns true if one string contains another",1],[10,"contains_char","","Returns true if a string contains a char.",1],[10,"chars","","An iterator over the characters of `self`. Note, this iterates\nover Unicode code-points, not Unicode graphemes.",1],[10,"bytes","","An iterator over the bytes of `self`",1],[10,"char_indices","","An iterator over the characters of `self` and their byte offsets.",1],[10,"split","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`.",1],[10,"splitn","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`, restricted to splitting at most `count`\ntimes.",1],[10,"split_terminator","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`.",1],[10,"rsplitn","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`, starting from the end of the string.\nRestricted to splitting at most `count` times.",1],[10,"match_indices","","An iterator over the start and end indices of the disjoint\nmatches of `sep` within `self`.",1],[10,"split_str","","An iterator over the substrings of `self` separated by `sep`.",1],[10,"lines","","An iterator over the lines of a string (subsequences separated\nby `\\n`). This does not include the empty string after a\ntrailing `\\n`.",1],[10,"lines_any","","An iterator over the lines of a string, separated by either\n`\\n` or `\\r\\n`. As with `.lines()`, this does not include an\nempty trailing line.",1],[10,"char_len","","Returns the number of Unicode code points (`char`) that a\nstring holds.",1],[10,"slice","","Returns a slice of the given string from the byte range\n[`begin`..`end`).",1],[10,"slice_from","","Returns a slice of the string from `begin` to its end.",1],[10,"slice_to","","Returns a slice of the string from the beginning to byte\n`end`.",1],[10,"slice_chars","","Returns a slice of the string from the character range\n[`begin`..`end`).",1],[10,"starts_with","","Returns true if `needle` is a prefix of the string.",1],[10,"ends_with","","Returns true if `needle` is a suffix of the string.",1],[10,"trim_chars","","Returns a string with characters that match `to_trim` removed from the left and the right.",1],[10,"trim_left_chars","","Returns a string with leading `chars_to_trim` removed.",1],[10,"trim_right_chars","","Returns a string with trailing `chars_to_trim` removed.",1],[10,"is_char_boundary","","Check that `index`-th byte lies at the start and/or end of a\nUTF-8 code point sequence.",1],[10,"char_range_at","","Pluck a character out of a string and return the index of the next\ncharacter.",1],[10,"char_range_at_reverse","","Given a byte position and a str, return the previous char and its position.",1],[10,"char_at","","Plucks the character starting at the `i`th byte of a string.",1],[10,"char_at_reverse","","Plucks the character ending at the `i`th byte of a string.",1],[10,"as_bytes","","Work with the byte buffer of a string as a byte slice.",1],[10,"find","","Returns the byte index of the first character of `self` that\nmatches `search`.",1],[10,"rfind","","Returns the byte index of the last character of `self` that\nmatches `search`.",1],[10,"find_str","","Returns the byte index of the first matching substring",1],[10,"slice_shift_char","","Retrieves the first character from a string slice and returns\nit. This does not allocate a new string; instead, it returns a\nslice that point one character beyond the character that was\nshifted. If the string does not contain any characters,\na tuple of None and an empty string is returned instead.",1],[10,"subslice_offset","","Returns the byte offset of an inner slice relative to an enclosing outer slice.",1],[10,"as_ptr","","Return an unsafe pointer to the strings buffer.",1],[10,"utf16_units","","Return an iterator of `u16` over the string encoded as UTF-16.",1],[10,"len","","Return the number of bytes in this string",1],[10,"is_empty","","Returns true if this slice contains no bytes",1],[10,"clone","","",3],[10,"next","","",3],[10,"next_back","","",3],[10,"clone","","",4],[10,"next","","",4],[10,"clone","","",5],[10,"next","","",5],[10,"clone","","",6],[10,"next","","",6],[10,"clone","","",7],[10,"next","","",7],[10,"size_hint","","",7],[10,"next_back","","",7],[10,"clone","","",8],[10,"next","","",8],[10,"size_hint","","",8],[10,"next_back","","",8],[10,"clone","","",9]],"paths":[[1,"CharRange"],[1,"Str"],[6,"AsStr"],[1,"CharSplits"],[1,"CharSplitsN"],[1,"MatchIndices"],[1,"StrSplits"],[1,"Chars"],[1,"CharOffsets"],[1,"Utf16CodeUnits"]]};
initSearch(searchIndex);
